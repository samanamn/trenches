//!
//! @file    trenches.h
//! @author Замятин Василий
//!
//! @brief итак, вот я пожарив окорочок, а потом поим когда остыне. Это прототип библиотеки будущей игры

struct sprite
{
    int x1,y1,V,timing;
    int state;
    int color;
    HDC adam;
    void draw();
    void moving();
    void death();
};
struct shooting
{
    int x1,y1;
    int state;
    double scale;
    HDC blowup;
    void draw();

};

struct map
{
    int A[20][30];
    void draw1();
    void draw2();
    void one();
    void two();
    int counting;
    //void three();
    int getpixel(int x, int y);
};
void sprite::draw()
{
        if(state==0)
            txTransparentBlt(txDC(), x1, y1, 25, 60, adam, 483, 319, TX_WHITE);
        if(state==1)
            txTransparentBlt(txDC(), x1, y1, 25, 60, adam, 519, 319, TX_WHITE);
        if(state==2)
            txTransparentBlt(txDC(), x1, y1, 25, 60, adam, 552, 319, TX_WHITE);
        if(state==3)
            txTransparentBlt(txDC(), x1, y1, 25, 60, adam, 446, 319, TX_WHITE);
        if(state==4)
            txTransparentBlt(txDC(), x1, y1, 25, 60, adam, 410, 319, TX_WHITE);
        if(state==5)
            txTransparentBlt(txDC(), x1, y1, 25, 60, adam, 374, 319, TX_WHITE);
        if(state==6)
            txTransparentBlt(txDC(), x1, y1, 30, 64, adam, 370, 316, TX_WHITE);
        if(state==7)
            txTransparentBlt(txDC(),x1, y1, 30, 64, adam, 407, 316, TX_WHITE);
        if(state==8)
            txTransparentBlt(txDC(), x1,y1, 30, 64,adam, 443, 316, TX_WHITE);
        if(state==9)
            txTransparentBlt(txDC(), x1, y1, 30, 64, adam, 479, 316, TX_WHITE);
        if(state==10)
            txTransparentBlt(txDC(), x1,y1, 30, 64, adam, 515, 316, TX_WHITE);
        if(state==11)
            txTransparentBlt(txDC(), x1,y1, 30, 64,adam, 551, 316, TX_WHITE);
}
void sprite::moving()
{
    if(color==1)
        V=7;
    else
        V=5;
         if(GetAsyncKeyState(VK_LEFT))
        {
            x1=x1-V;
            if(state==3)
                if(timing==4)
                {
                    state=4;
                    timing=5;
                }
                else
                {
                    state=5;
                    timing=4;
                }
            else
                state=3;
        }
        if(GetAsyncKeyState(VK_RIGHT))
        {
            x1=x1+V;
            if(state==0)
                if(timing==1)
                {
                    state=1;
                    timing=2;
                }
                else
                {
                    state=2;
                    timing=1;
                }
            else
                state=0;
        }

}
void sprite::death()
{
    txSetFillColor(TX_BLACK);
    txClear();
    txSleep(700);
    x1=50;
    txSleep(300);
}
void map::draw1()
{
    int i,j;
    txSetColor(TX_TRANSPARENT);
    for(i=0;i<20;i++)
        for(j=0;j<30;j++)
        {

            if(A[i][j]==1)
                txSetFillColor(TX_BLACK);
            txRectangle(0+j*40,0+i*40,40+j*40+1,40+i*40);
        }
}
void map::draw2()
{
    int i,j;
    txSetColor(TX_TRANSPARENT);
    for(i=0;i<20;i++)
        for(j=0;j<30;j++)
        {
            if(A[i][j]==0)
                txSetFillColor(RGB(204,0,51));
            if(A[i][j]==1)
                txSetFillColor(TX_TRANSPARENT);
            if(A[i][j]==2)
                txSetFillColor(RGB(204,153,102));
            if(A[i][j]==3)
                txSetFillColor(RGB(255,255,153));
            if(A[i][j]==4)
                txSetFillColor(TX_WHITE);
            if(A[i][j]==5)
                txSetFillColor(RGB(153,204,204));
            txRectangle(0+j*40,0+i*40,40+j*40+1,40+i*40);
        }
}
void map::one()
{
    int i,j;
    int B[20][30]= {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1,1, 1, 1, 1, 2, 2, 1, 1, 1, 1,
                    5, 5, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1,1, 1, 1, 1, 2, 2, 1, 1, 1, 1,
                    5, 5, 5, 1, 1, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 5, 5, 5, 1, 1,1, 1, 1, 2, 2, 2, 1, 1, 1, 5,
                    5, 5, 5, 1, 1, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 5, 5, 5, 1, 2,2, 1, 1, 2, 2, 2, 2, 1, 1, 5,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
    for(i=0;i<20;i++)
        for(j=0;j<30;j++)
        {
            A[i][j]=B[i][j];
        }
}
void map::two()
{
    int i,j;
    int B[20][30]= {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1, 5, 1, 1, 1, 1, 1, 1, 1, 1,
                    1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1,5, 5, 1, 1, 1, 1, 1, 1, 1, 1,
                    2, 2, 1, 1, 1, 5, 5, 1, 1, 1, 1, 5, 1, 1, 1, 2, 2, 1, 1, 5,5, 5, 1, 1, 1, 1, 1, 1, 1, 2,
                    2, 2, 2, 1, 5, 5, 5, 1, 1, 1, 1, 5, 1, 2, 1, 2, 2, 1, 1, 5,5, 5, 1, 1, 1, 1, 2, 1, 2, 2,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                    3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3,3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
    for(i=0;i<20;i++)
        for(j=0;j<30;j++)
        {
            A[i][j]=B[i][j];
        }
}
int map::getpixel(int x, int y)
{
    if(A[(y/20)][x/30]==1)
        return 0;
    else
        return 1;
}
void shooting::draw()
{
        if(state==1)
            //txTransparentBlt(txDC(), x1, y1, 40, 40, blowup, 0, 0, TX_BLACK);
            Win32::TransparentBlt(txDC(), x1-20 , y1-20, 40*scale, 40*scale,blowup, 0, 0, 40, 40, TX_BLACK);
        if(state==2)
            txTransparentBlt(txDC(), x1, y1, 40, 40, blowup, 552, 319, TX_BLACK);
}
